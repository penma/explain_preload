#!/usr/bin/env perl
use strict;
use warnings;
use 5.026;
use autodie;
use IO::Zlib;

my @func_blacklist = (
	qw(fcntl ioctl open openat), # varargs
	qw(pipe), # different argument variants
	qw(ptrace), # just no
	qw(malloc free calloc), # just too hairy!
	qw(fpurge), # supported by libexplain but not available under linux
#	qw(statfs), # XXX figure out when and why this caused problems
	qw(wait wait3 wait4 waitpid), # those caused massive problems, TODO fix this
	qw(stat lstat fstat), # not part of binary interface, must be wrapped separately: http://refspecs.linux-foundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/baselib---xstat.html
);

my $initfunc_impls = ""; # implementations that just dlsym(RTLD_NEXT) because called very early
my $realfunc_decls = ""; # declaration of real_NAME variables
my $realfunc_inits = ""; # initialization code for real_NAME
my $wrapfunc_impls = ""; # the actual wrappers

for my $fn (@ARGV) {
	open(my $catfile, "<", $fn);
	my $content = join("", <$catfile>);
	unless ($content =~ /Prototype: (.*?);?\n\S/ms) {
		print STDERR "\e[31mbogus file $fn\e[m\n";
		next;
	}
	my $proto = ($1 =~ s/\n\s*/ /gmr);
	#print STDERR "call: $proto\n";
	unless ($proto =~ /^(.*?)\s*(\w+)\((.*)\)$/) {
		print STDERR "\e[31mbogus proto: $proto\e[m\n";
		next;
	}
	my ($return_type, $name, $params) = ($1, $2, $3);

	# better proto from manpage
	my $manpage = IO::Zlib->new("/usr/share/man/man3/$name.3.gz", "rb");
	if (!$manpage) {
		$manpage = IO::Zlib->new("/usr/share/man/man2/$name.2.gz", "rb");
		if (!$manpage) {
			print STDERR "\e[31munable to open manpage entry for $name\e[m\n";
			next;
		}
	}
	my $man_content = join("", <$manpage>);
	unless ($man_content =~ /^\.BI? ([^\n]*?\b\Q$name\E\(.*?\));"?$/ms) {
		print STDERR "\e[31mfailed to find manpage entry for $name\e[m\n";
		next;
	}
	my $man_proto = ($1 =~ s/^\.(?:BI|br|B)?\s+|"|\n|\\$/ /gmr);
	$man_proto =~ s/\s+/ /g;
	#print STDERR "manpage entry: $man_proto\n";

	unless ($man_proto =~ /^\s*(.*?)\s*(\w+)\((.*)\)$/) {
		print STDERR "\e[31mbogus manpage proto: $man_proto\e[m\n";
		next;
	}
	($return_type, $name, $params) = ($1, $2, $3);

	if (grep { $_ eq $name } @func_blacklist) {
		print STDERR "\e[33mskipping $name because of reasons\e[m\n";
		next;
	}

	my @params;
	if ($params ne "void") {
		@params = split /,\s*/, $params;
	}
	my @param_names = map { m/(\w+)\s*(?:\[\d*\]\s*)?$/ } @params;
	my $params_arglist = join(", ", @param_names);
	#use Data::Dump; dd({ name => $name, params => \@params,  params_arglist => $params_arglist, param_names => \@param_names });

	$realfunc_decls .= "static $return_type (*real_$name)($params) = INIT_$name;\n";
	$realfunc_inits .= "\treal_$name = dlsym(RTLD_NEXT, \"$name\");\n";
	if ($return_type eq "void") {
		$wrapfunc_impls .= <<~"END;";
			void $name($params) {
				if (explainpreload_wrap_enter()) {
					explain_${name}_on_error($params_arglist);
					explainpreload_wrap_leave();
				} else {
					real_$name($params_arglist);
				}
			}
			END;
		$initfunc_impls .= <<~"END;";
			static void INIT_$name($params) {
				void (*f)($params);
				f = dlsym(RTLD_NEXT, "$name");
				f($params_arglist);
			}
			END;
	} else {
		$wrapfunc_impls .= <<~"END;";
			$return_type $name($params) {
				if (explainpreload_wrap_enter()) {
					$return_type retval = explain_${name}_on_error($params_arglist);
					explainpreload_wrap_leave();
					return retval;
				} else {
					return real_$name($params_arglist);
				}
			}
			END;
		$initfunc_impls .= <<~"END;";
			static $return_type INIT_$name($params) {
				$return_type (*f)($params);
				f = dlsym(RTLD_NEXT, "$name");
				return f($params_arglist);
			}
			END;
	}
}

print << "END";
// This file is auto-generated by: make update_autofuncs
#define _GNU_SOURCE
#include <dlfcn.h>

#include <poll.h>

#include <libexplain/libexplain.h>

#include "wrap.h"

$initfunc_impls
$realfunc_decls
static void resolve_real_functions(void) __attribute__((constructor));
static void resolve_real_functions(void) {
$realfunc_inits
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
$wrapfunc_impls
#pragma GCC diagnostic pop
END

